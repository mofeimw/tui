#!/usr/bin/env bash

# recalculate window size and redraw
refresh() {
    # get dimensions
    read -r LINES COLUMNS < <(stty size)

    # set global variable for the center of the page
    ((CENTER = COLUMNS / 2))

    # create empty array to add elements to render
    elements=()

    # set cursor to first index
    cursor=0
    
    # construct home page
    br
    h1 "tui program"
    br

    # draw to terminal
    draw
}

# clear screen and render each element
draw() {
    # escape code to clear screen
    printf '\033[2J\033[H\033[?25l'

    # loop through elements and write to terminal
    for element in "${elements[@]}"; do
        echo -e "$element"
    done

    # loop through <select>
    for option in "${selectable[@]}"; do
        # test if the option has been selected by user, and print color codes accordingly
        if [[ "${selected[@]}" =~ "${option}" ]]; then
            printf '\033[1m\033[42m\033[30m%s\033[m\n' "$option"
        else
            [ "${selectable[$cursor]}" == "$option" ] && printf '\033[1m\033[32m%s\033[m\n' "- $option" || printf '\033[1m\033[34m%s\033[m\n' "$option"
        fi
    done
}

# <h1>
h1() {
    # find z value with respect to the center point and the length of the string
    [ $(((COLUMNS - ${#1}) % 2)) -eq 0 ] && ((z = CENTER - ${#1} / 2)) || ((z = CENTER - ${#1} / 2 - 1))

    # fill output variable with appropriate amount of spaces to create banner
    out=""
    for ((i=0; i<z; i++)); { out+=" "; }
    out+="$1"
    for ((i=0; i<z; i++)); { out+=" "; }

    # add to elements and draw
    elements+=$(printf '\033[1m\033[44m\033[30m%s\033[m' "$out")
    draw
}

# <p>
p() {
    # adds bold blue <p> and fills the rest of the line with blank space
    elements+=$(printf '\033[1m\033[34m%s\033[m' "$1")
    elements+=$(for ((i=0; i<$COLUMNS-${#1}; i++)); { echo -n " "; })
    draw
}

# <br>
br() {
    # writes a full line of blank space
    elements+=$(for ((i=0; i<$COLUMNS; i++)); { echo -n " "; })
    draw
}

# <select>
choice() {
    # constructs a <select> with the arguments provided, adding them to the selectable array
    for option in "$@"; do
        selectable+=("$option")
    done
    
    # (re)draw
    draw
}

# event handlers
# adjusts the cursor position and adjusts snapback to prevent array index out of bounds
up() { ((cursor--)); [ $cursor -eq -1 ] && ((cursor = ${#selectable[@]} - 1)); draw; }
down() { ((cursor++)); [ $cursor -eq ${#selectable[@]} ] && cursor=0; draw; }

# idk what to do with these yet
left() { p "left"; }
right() { p "right"; }

# "click" event handler
click() {
    # if no other selections have been made add the selected into the array
    [ ${#selected[@]} -eq 0 ] && {
        selected+=("${selectable[$cursor]}")
        draw
        return 0
    }

    # loop through each selected item
    for item in "${selected[@]}"; do
        # deselect item if it was already within the selected array
        [ "${selectable[$cursor]}" == "$item" ] && {
            # create new array and repopulate without the deselected option - this is to avoid leaving a gap in the indices
            new=()

            for value in "${selected[@]}"; do
                [[ "$value" != "$item" ]] && new+=($value)
            done

            selected=("${new[@]}")
            unset new

        # add selection if it was previously unselected
        } || selected+=("${selectable[$cursor]}")
    done

    # (re)draw
    draw
}

# map keys
keystroke() {
    # map escape codes
    [ -n $escape ] && {
        case $key in
            A)
                up
            ;;

            B)
                down
            ;;

            D)
                left
            ;;

            C) 
                right
            ;;
        esac

        unset escape
    }

    # set flag because escape keys send two seperate triggers
    [ "$key" == "[" ] && escape=true

    # map regular keys (vim-like keybinds yay)
    case $key in
        k)
            up
        ;;

        j)
            down
        ;;

        h)
            left
        ;;

        l)
            right
        ;;

        " "|"")
            click
        ;;

        q)
            exit 0
        ;;
    esac
}

# main function
main() {
    # hide input and read keys one at a time
    stty -icanon -echo

    # catch window resizes and exits
    trap 'refresh' WINCH
    trap "stty icanon echo; printf '\033[?25h\033[2J\033[H'" EXIT INT

    # set up "dom"
    elements=()

    # add arrays for <select>s
    selectable=()
    selected=()

    # fresh start
    refresh

    # render some more elements
    p "hola"
    br
    choice "one" "two" "three" "four"

    # forever loop reading keys
    while key=$(dd ibs=1 count=1 2>/dev/null); do
        keystroke
    done
}

main "$@"
