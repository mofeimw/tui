#!/usr/bin/env bash

# clear screen and render each element
render() {
    # escape code to clear screen
    printf '\033[2J\033[H\033[?25l'

    # render header
    header "tui program"
    
    # render message status line if necessary
    [ ! "$msg" == "" ] && msg "$msg"

    # loop through body elements and write to print
    for element in "${body[@]}"; do
        echo -e "$element"
    done

    # loop through <select>able elements and print
    for option in "${selectable[@]}"; do
        # test if the option has been selected by user
        if [[ "${selected[@]}" =~ "${option}" ]]; then
            [ "${selectable[$cursor]}" == "$option" ] && printf '\033[1m\033[45m\033[30m%s\033[m\n' "- $option" || printf '\033[1m\033[42m\033[30m%s\033[m\n' "$option"
        else
            [ "${selectable[$cursor]}" == "$option" ] && printf '\033[1m\033[32m%s\033[m\n' "- $option" || printf '\033[1m\033[34m%s\033[m\n' "$option"
        fi
    done

    # render submit button based on state
    [ "${submit[0]}" == visible ] && {
        for ((i=0; i<$COLUMNS; i++)); { echo -n " "; }
        printf '\033[1m\033[46m\033[30mdone\033[m\n'
    }

    [ "${submit[0]}" == selected ] && {
        for ((i=0; i<$COLUMNS; i++)); { echo -n " "; }
        printf '\033[1m\033[45m\033[30mdone\033[m\n'
    }
}

# recalculate window size and rerender
refresh() {
    # get dimensions
    read -r LINES COLUMNS < <(stty size)

    # rerender
    render
}

# hard reset
hard_reset() {
    selectable=()
    selected=()
    submit=""

    refresh
}

# print header
header() {
    # find z value with respect to the center point
    ((z = (COLUMNS - "${#1}") / 2 ))

    # fill output variable with appropriate amount of spaces to create banner
    out=""
    for ((i=0; i<z; i++)); { out+=" "; }
    out+="$1"
    for ((i=0; i<z; i++)); { out+=" "; }

    # add space to compensate for odd number of columns
    [ ! $(((COLUMNS - ${#1}) % 2)) -eq 0 ] && out+=" "

    # write to stdout, with top and bottom padding
    for ((i=0; i<$COLUMNS; i++)); { echo -n " "; }
    printf '\033[1m\033[44m\033[30m%s\033[m' "$out"
    for ((i=0; i<$COLUMNS; i++)); { echo -n " "; }
}

# print status message
msg() {
    printf '\033[1m\033[34m%s\033[m' "$1"
    for ((i=0; i<($COLUMNS*2)-${#1}; i++)); { echo -n " "; }
}

# add <p> to <body>
p() {
    # adds bold blue <p> and fills the rest of the line with blank space
    body+=$(printf '\033[1m\033[34m%s\033[m' "$1")
    body+=$(for ((i=0; i<$COLUMNS-${#1}; i++)); { echo -n " "; })
    render
}

# add <br> to body
br() {
    # writes a full line of blank space
    body+=$(for ((i=0; i<$COLUMNS; i++)); { echo -n " "; })
    render
}

# construct a <select>
choice() {
    # loop through arguments and add to (selectable) array
    for option in "$@"; do
        selectable+=("$option")
    done
    render
}

# file browser functionality
browser() {
    for file in "${data[@]}"; do
        [ ! -f "$file" ] && {
            hard_reset
            p "file not found!"
        }
    done
}

# submit button
submit() {
    # make sure there is at least one selection
    [ ${#selected[@]} -eq 0 ] && return 1

    # grab submitted form data
    data=("${selected[@]}") 

    # change message
    msg="submitted!"
    
    hard_reset

    # route flow depending on api
    [ ${submit[1]} == opt ] && { 
        for option in "${data[@]}"; do
            $option
        done
    }

    [ ${submit[1]} == fs ] && browser
}

# event handlers
# adjusts the cursor position and adjusts snapback to prevent array index out of bounds
up() {
    ((cursor--))
    curse
}

down() {
    ((cursor++))
    curse
}

# cursor logic
curse() {
    # move selection away from submit button if it was already selected
    [ ${submit[0]} == selected ] && {
        cursor=0
        submit[0]=visible
    }

    # submit button state
    [ ${submit[0]} == visible ] && {
        [ $cursor -eq ${#selectable[@]} ] && submit[0]=selected
    } || {
        [ $cursor -eq ${#selectable[@]} ] && cursor=0
    }
    [ $cursor -eq -1 ] && ((cursor = ${#selectable[@]} - 1))

    render
}

# idk what to do with these yet
left() { :; }
right() { :; }

# "click" event handler
click() {
    # call submit() to send data
    [ ${submit[0]} == selected ] && { submit; return 0; }

    # if no other selections have been made add the selected into the array
    [ ${#selected[@]} -eq 0 ] && {
        selected=("${selectable[$cursor]}")
        render
        return 0
    }

    # loop through each selected item
    for item in "${selected[@]}"; do
        # deselect item if it was already within the selected array
        [ "${selectable[$cursor]}" == "$item" ] && {
            # create new array and repopulate without the deselected option - to avoid leaving a gap in the indices
            new=()

            for value in "${selected[@]}"; do
                [ ! "$value" == "$item" ] && new+=($value)
            done

            selected=("${new[@]}")
            unset new

            render
            return 0
        }
    done

    selected+=("${selectable[$cursor]}")
    render
}

# map keys
keystroke() {
    # map escape codes
    [ -n $escape ] && {
        case $key in
            A)
                up
            ;;

            B)
                down
            ;;

            D)
                left
            ;;

            C) 
                right
            ;;
        esac

        unset escape
    }

    # set flag because escape keys send two seperate triggers
    [ "$key" == "[" ] && escape=true

    # map regular keys (vim-like keybinds yay)
    case $key in
        k)
            up
        ;;

        j)
            down
        ;;

        h)
            left
        ;;

        l)
            right
        ;;

        " "|"")
            click
        ;;

        q)
            exit 0
        ;;
    esac
}

# --- filler logic functions - replace with the options in your <select> ---
one() {
    p "one!"
}

two() {
    p "two!!"
}

three() {
    p "three!!!"
}

four() {
    p "four!!!!"
}

# main() function
main() {
    # hide input and read keys one at a time
    stty -icanon -echo

    # catch window resizes and exits
    trap 'refresh' WINCH
    trap "stty icanon echo; printf '\033[?25h\033[2J\033[H'" EXIT INT

    # set up "dom"
    body=()
    selectable=()
    selected=()
    cursor=0

    msg="hola"

    # fresh start
    refresh

    # add some elements
    choice "one" "two" "three" "four"

    submit=(visible opt)

    # render!
    render

    # forever loop reading keys
    while key=$(dd ibs=1 count=1 2>/dev/null); do
        keystroke
    done
}

main "$@"
